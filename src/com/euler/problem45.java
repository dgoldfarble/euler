package com.euler;

import java.util.HashSet;

/**
 * Created by dgoldfarb on 7/16/15.

 QUESTION
 Pentagonal numbers are generated by the formula, Pn=n(3n−1)/2. The first ten pentagonal numbers are:

 1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...

 It can be seen that P4 + P7 = 22 + 70 = 92 = P8. However, their difference, 70 − 22 = 48, is not pentagonal.

 Find the pair of pentagonal numbers, Pj and Pk, for which their sum and
 difference are pentagonal and D = |Pk − Pj| is minimised; what is the value of D?

 ANSWER OPTION ONE
   - Generate a small list of pentagonal numbers (say, 10,000)
   - iterate through all pairs to find a pair satisfying the condition
   - use that pair's difference as an upper bound

 ANSWER OPTION TWO
   - given a list of the first n - 1 pentagonals
   - find the difference P(n) - P(n - 1), and use as a lower bound for iterating through the pairs
   - find the sum P(n) + P(n + 1) and use
   - iterate through pairs, seeing if difference between
 */
public class Problem45 {
    HashSet<Long> pentagonals;

    Problem45() {
        pentagonals = new HashSet<Long>();
    }

    public static void main(String[] args) {
        Problem45 p45 = new Problem45();
        p45.run2(1000000);
        // p45.run();
    }

    private void run2(int max) {
        generatePentagonals(max);
        for (int i = 0; p(i) < max) {
            
        }
    }

    private void run() {
        pentagonals.add((long) 1);
        pentagonals.add((long) 5);
        int n = 3;
        boolean found = false;
        long baseline = Long.MAX_VALUE;
        while (!found) {
            long pn = p(n);
            fillOut(n);

            long diff = pn - p(n - 1);
            System.out.println(n);
            for (int i = (int) pInv(diff); i < n; i++) {
                long pi = p(i);
                if (pentagonals.contains(pn - pi) && pentagonals.contains(pn + pi)) {
                    System.out.println("Pair " + pn + ", " + pi + " satisfy requirement");
                    if (pn - pi < baseline) {
                        baseline = pn - pi;
                    }
                }
            }

            if (n % 1000 == 0) {
                System.out.println(n);
            }
            n++;
        }
    }

    private void fillOut(int n) {
        for (int i = n; p(i) < p(n) + p(n - 1) && p(i) > 0; i++) {
            pentagonals.add((long) p(i));
        }
    }

    private long p(int n) {
        long result = (long) n;
        result = result * (long) ((3 * n - 1) / 2);
        assert(result > 0);
        return result;
    }

    private HashSet<Long> generatePentagonals(long max) {
        HashSet<Long> set = new HashSet<Long>();
        for (int i = 0; p(i) > 0 && p(i) <= max; i++) {
            set.add(p(i));
        }
        return set;
    }

    private double pInv(long p) {
        // p = 1 / 24 * (36n^2 - 12n + 1 - 1) = 1 / 24 * ((6n - 1)^2 - 1)
        return (Math.sqrt(24 * p + 1) + 1) / 6;
        // I wonder what I did wrong here...
        // p = 3 / 2 * (n^2 - 1/3n + 1/36 - 1/36) = 3 / 2 * ((n - 1/6) ^2 - 1/36)
        // return Math.sqrt(p * 2/3 + 1/36) + 1/6;
    }
}
